/*******************************************************************
 * CLASS: HeatmapDataGenerator
 *
 * This class is the driver for the heat map data generation process. 
 * import data matrix files are read in and clustered.  Data tiles, 
 * containing binary data representation of the matrix data are 
 * written out.  Finally, tile structure and column header json 
 * files are generated by the process.
 * 
 * Author: Mark Stucky
 * Date: December 14, 2015
 ******************************************************************/

package mda.ngchm.datagenerator;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Date;
import java.util.ArrayList;
import java.io.OutputStreamWriter;

import mda.ngchm.datagenerator.ImportData;
import static mda.ngchm.datagenerator.ImportConstants.*;


public class HeatmapDataGenerator {

	public static void main(String[] args) {
		System.out.println("START: " + new Date()); 
		// Create ImportData object for data matrix.  This object will 
		// contain subordinate objects for import layers and import tiles
		ImportData iData =  new ImportData(args);
		int summaryInterval = 0;
		// Loop thru ImportData object processing for each ImportDataLayer
		for (int i=0; i < iData.importLayers.size(); i++) {
			ImportLayerData ilData = iData.importLayers.get(i);
			if (ilData.layer.equals(LAYER_SUMMARY)) {
				summaryInterval = ilData.rowInterval;
			}
			// Within each ImportDataLayer, loop thru each of its 
			// ImportTileData objects writing out a tile for each
			for (int j=0; j < ilData.importTiles.size(); j++){
				ImportTileData itData = ilData.importTiles.get(j);
				writeTileFile(iData, ilData, itData);
			}
		}
		// Generate tileStructure.json file for data import
		writeTileStructFile(iData);
		// Generate import row and column label .json files for the import
		writeLabelsFiles(iData.outputDir + ROW_LABELS_FILE, iData, true);
		writeLabelsFiles(iData.outputDir + COL_LABELS_FILE, iData, false);
		writeDendrogramFile(iData, summaryInterval);
		writeClassificationsFile(iData, summaryInterval);
		writeColorMapFile(iData);
		if (DEBUG) {
			writeClusteredDebugFile(iData);
		}
		System.out.println("END: " + new Date());  
	}

	/*====================================================================
	 * BEGIN: DATA TILE FILE WRITING METHODS
	 *
	 * The methods that follow are concerned with writing out data tile
	 * output files to the various tile "level" output directories.
	 *====================================================================*/

	/*******************************************************************
	 * METHOD: writeTileFile
	 *
	 * This method writes out individual data tile files by iterating 
	 * thru the data matrix string array, stored on the ImportData object,
	 * and writing out individual binary float values using the ImportLayerData 
	 * and ImportTileData objects as a guideline.
	 ******************************************************************/
	private static void writeTileFile(ImportData iData, ImportLayerData ilData, ImportTileData itData) {
		int writes = 0;
	    try {
	    	//If tile destination dir does not exist, create directory.
	    	File dataDir = new File(iData.outputDir+File.separator+ilData.layer);
	    	if (!dataDir.exists()) {
	    		dataDir.mkdirs();
	    	}
			DataOutputStream write = new DataOutputStream(new FileOutputStream(iData.outputDir + itData.fileName));
			int rowStart = itData.rowStartPos, rowEnd = itData.rowEndPos;
			int colStart = itData.colStartPos, colEnd = itData.colEndPos; 
			int rowInterval = ilData.rowInterval, colInterval = ilData.colInterval;
			int nextColWrite = 0;
			int nextRowWrite = getNextRowWrite(ilData, rowStart);
			int nextCol = getNextColWrite(ilData, colStart);
			DataOutputStream writeRow=null;
			if (DEBUG) { writeRow = new DataOutputStream(new FileOutputStream(iData.outputDir  + itData.fileName + TXT_FILE));  }//For debugging: writes out file
			for (int row = rowStart; row < rowEnd; row++) {
				if (row == nextRowWrite) {
					nextColWrite = nextCol;
					String valprint = null;
					if (DEBUG) { valprint = Integer.toString(row); } //For debugging: writes out file
					for (int col = colStart; col < colEnd; col++) {
						if (col == nextColWrite) {
							float v = getMatrixValue(iData,ilData,row,col);
							byte f[] = ByteBuffer.allocate(4).putFloat(v).array();
							if (DEBUG) { valprint = valprint + TAB + v; } //For debugging: writes out file
							write.write(f, 3, 1);
							write.write(f, 2, 1);
							write.write(f, 1, 1);
							write.write(f, 0, 1); 
							writes++;
							nextColWrite += colInterval;
						}
					}
					if (DEBUG) { 
						valprint = valprint + "\r\n";  //For debugging: writes out file
						writeRow.writeChars(valprint); 
					} 
					nextRowWrite += rowInterval;
				} 
			}
	    	if (DEBUG) { writeRow.close(); } //For debugging: writes out file
	    	System.out.println("     File " + itData.fileName + " writes: " + writes) ;
	    } catch (NumberFormatException ex) {
	    	System.out.println("ERROR: Non-numeric data found in matrix"+ ex.toString());
	    	return;
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    }
	}
	
	/*******************************************************************
	 * METHOD: getMatrixValue
	 *
	 * This method retrieves the matrix value to be written out to a given
	 * data tile. If the sampling method of "sample" is being used, the 
	 * value associated with the row/col passed in is returned. If the 
	 * sampling method is "average" or "predominance" an array is populated 
	 * containing all of the values in the range of the current value based
	 * upon the row/col intervals.  If the method is average, the value 
	 * returned will be the average of all values in the array. If the 
	 * method is "predominance", the value that re-occurs the most in the
	 * array is returned. 
	 ******************************************************************/
	private static float getMatrixValue(ImportData iData, ImportLayerData ilData, int row, int col) throws NumberFormatException
	{  
	  float value = 0;
	  try {
		  if (iData.summaryMethod.equals(METHOD_SAMPLE)) {
			  value = Float.parseFloat(iData.reorgMatrix[row][col]);
		  }	else  {
			  int rowInter = ilData.rowInterval;
			  int colInter = ilData.colInterval;
			  if (rowInter+colInter == 2) {
				  value = Float.parseFloat(iData.reorgMatrix[row][col]);
			  } else {
				  //We must check if we are going past the max row/cols and adjust the 
				  //boundary for our loop AND the interval value that will be used for averaging.
				  int rowBoundary = row+ilData.rowInterval;
				  int colBoundary = col+ilData.colInterval;
				  if (rowBoundary>=iData.reorgMatrix.length) {
					  rowBoundary = iData.reorgMatrix.length;
					  rowInter = rowBoundary - row;
				  }
				  if (colBoundary>=iData.reorgMatrix[0].length) {
					  colBoundary = iData.reorgMatrix[0].length;
					  colInter = colBoundary - col;
				  }
				  int combInter = (rowInter*colInter);
				  float[] valArr = new float[combInter];
				  int valArrIdx = 0;
				  // Grab all values in the prescribed bounded range and place them in an array
				  for (int i = row; i < rowBoundary;i++) {
					  for (int j = col; j < colBoundary;j++) {
						  if (isNumeric(iData.reorgMatrix[i][j])) {
							  valArr[valArrIdx] = Float.parseFloat(iData.reorgMatrix[i][j]);
							  valArrIdx++;
						  } else {
							  throw new NumberFormatException();
						  }
					  }
				  }
				  if (iData.summaryMethod.equals(METHOD_AVERAGE)) {
					  value = getAverageValue(valArr, combInter);
				  } else if (iData.summaryMethod.equals(METHOD_MODE)) {
					  value = getPredominantValue(valArr);
				  }
			  }
		  }	
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    }
	  return value;  
	}

	/*******************************************************************
	 * METHOD: getAverageValue
	 *
	 * This method iterates thru the array passed, in summing all of the
	 * values contained therein. That value is then divided by the 
	 * combined row/col interval.
	 ******************************************************************/
	private static float getAverageValue(float[] array, int combInter) {
		float value = 0;
		// sum the values in the array
		for (int k = 0; k < array.length; k++) {
			value = value + array[k];
		}
		// average the summed total
		return value / combInter;
	}
	
	/*******************************************************************
	 * METHOD: getPredominantValue
	 *
	 * This method iterates thru the array passed in, summing the 
	 * number occurrences of each value in the array and returns the 
	 * value with the most occurrences. If more than one value occurs the 
	 * same amount of times, the first value encountered is returned.
	 ******************************************************************/
	private static float getPredominantValue(float[] array){
		float value = 0;
        ArrayList<Float> distinctVals = new ArrayList<>();
        // loop original array adding distinct values to ArrayList
        for(int i= 0; i< array.length; i++) {
            boolean found = false;
            float iVal = array[i];
            // loop distinct values to see if current value already exists
            for (int v =0; v<distinctVals.size(); v++) {
                if(distinctVals.get(v)==iVal) {
                  found = true;
                  break;
                }
            }
            // add distinct value to ArrayList is not found
            if (!found) {
            	distinctVals.add(iVal);
            }
        }
        // create array for storing counts based on number of distinct values
        int [] arrayIndex= new int[distinctVals.size()];
        // loop distinct values array
        for(int i= 0; i< distinctVals.size(); i++) {
            int count = 0;
            // loop original array, counting occurrences of distinct value.
            for (int v =0; v<array.length; v++) {
                if(array[v] == distinctVals.get(i)) {
                  count++;
                }
            }
            arrayIndex[i] = count;
        }
        int highOcc = 0;
        int highIdx = 0;
        // Loop occurrences count array and set the index value
        // of the distinct value that has the most occurrences.
        for(int i= 0; i < arrayIndex.length; i++) {
        	int occ = arrayIndex[i];
        	if (occ > highOcc) {
        		highOcc = occ;
        		highIdx = i;
        	}
        }
        value = distinctVals.get(highIdx);
        return value;
    }

	/*******************************************************************
	 * METHOD: isNumeric
	 *
	 * A helper method evaluating a matrix data element to ensure that 
	 * it contains a numeric value.
	 ******************************************************************/
	public static boolean isNumeric(String str)  
	{  
	  try  {  
	    double d = Double.parseDouble(str);  
	  }   catch(Exception e)  { 
	    return false;  
	  }  
	  return true;  
	}

	/*******************************************************************
	 * METHOD: getNextRowWrite
	 *
	 * A helper method calculating the next row to write when beginning
	 * a new tile.  This is only used when an interval is being used
	 * for thumbnail, summary, and ribbon horizontal layer views.
	 ******************************************************************/
	private static int getNextRowWrite(ImportLayerData ilData, int rowStart) {	
		int nextRowWrite = rowStart;
		if (Arrays.asList(LAYER_THUMBNAIL, LAYER_SUMMARY, LAYER_RIBBONHORIZ).contains(ilData.layer)) {
			if ((rowStart != 1) && (ilData.rowInterval != 1)) {
				nextRowWrite = (((rowStart/ilData.rowInterval)*ilData.rowInterval)+1);
			}
		} 
		return nextRowWrite;
	}

	/*******************************************************************
	 * METHOD: getNextColWrite
	 *
	 * A helper method calculating the next column to write when beginning
	 * a new tile.  This is only used when an interval is being used
	 * for thumbnail, summary, and ribbon vertical layer views.
	 ******************************************************************/
	private static int getNextColWrite(ImportLayerData ilData, int colStart) {	
		int nextColWrite = colStart;
		if (Arrays.asList(LAYER_THUMBNAIL, LAYER_SUMMARY, LAYER_RIBBONVERT).contains(ilData.layer)) {
			if ((colStart != 1) && (ilData.colInterval != 1)) {
				nextColWrite = (((colStart/ilData.colInterval)*ilData.colInterval)+1);
			}
		} 
		return nextColWrite;
	}

	/*====================================================================
	 * END: TILE WRITING METHODS
	 *==================================================================*/


	/*====================================================================
	 * BEGIN: OUTPUT FILE WRITING METHODS
	 *
	 * The methods that follow, from here to the end of the file, write
	 * the various output files generated by the HeatmapDataGenerator 
	 * process.  They include:
	 * 1. The Tile Structure JSON File
	 * 2. Row and Column Labels JSON Files
	 * 3. The Dendrogram JSON file
	 * 4. The Classfications JSON file
	 *====================================================================*/
	
	/*******************************************************************
	 * METHOD: writeTileStructFile
	 *
	 * This method writes out the tilestructure.json file for the 
	 * generated heatmap. A thumb will always be written.  The levels 
	 * below will be written to the file if they are generated.
	 ******************************************************************/
	private static void writeTileStructFile(ImportData iData) {	
		DataOutputStream writeRow = null;
		OutputStreamWriter w = null;
		try {
			writeRow = new DataOutputStream(new FileOutputStream(iData.outputDir + TILE_STRUCT_FILE));
			w = new OutputStreamWriter(writeRow, UTF8);
			// Build String constants
			w.write(BRACE_OPEN+LINE_FEED+TAB+LEVELS_LABEL);
			w.write(LINE_FEED+TAB+BRACE_OPEN);
			// Loop thru import layers and write out structure data for each.
			for (int i=0; i < iData.importLayers.size(); i++) {
				ImportLayerData ilData = iData.importLayers.get(i);
				// Write out the Thumbnail file structure data.
				w.write(LINE_FEED+TAB+TAB+QUOTE+ilData.layer+QUOTE+COLON);
				w.write(LINE_FEED+TAB+TAB+BRACE_OPEN);
				w.write(LINE_FEED+TAB+TAB+TAB+TILEROWS_LABEL+ilData.rowTiles);
				w.write(COMMA+LINE_FEED+TAB+TAB+TAB+TILECOLS_LABEL+ilData.colTiles);
				w.write(COMMA+LINE_FEED+TAB+TAB+TAB+TILEROWSPER_LABEL+ilData.rowsPerTile);
				w.write(COMMA+LINE_FEED+TAB+TAB+TAB+TILECOLSPER_LABEL+ilData.colsPerTile);
				w.write(COMMA+LINE_FEED+TAB+TAB+TAB+TOTALROWS_LABEL+ilData.totalLevelRows);
				w.write(COMMA+LINE_FEED+TAB+TAB+TAB+TOTALCOLS_LABEL+ilData.totalLevelCols);
				w.write(COMMA+LINE_FEED+TAB+TAB+TAB+ROW_SUMMARY_RATIO_LABEL+ilData.rowInterval);
				w.write(COMMA+LINE_FEED+TAB+TAB+TAB+COL_SUMMARY_RATIO_LABEL+ilData.colInterval);
				w.write(LINE_FEED+TAB+TAB+BRACE_CLOSE);
				if (i < (iData.importLayers.size() - 1)) {
					w.write(COMMA);
				}
			}
			w.write(LINE_FEED+TAB+BRACE_CLOSE+LINE_FEED+BRACE_CLOSE);
			w.close();
			writeRow.close();
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    	try {
	    		w.close();
	    		writeRow.close();
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}

	/*******************************************************************
	 * METHOD: writeLabelsFile
	 *
	 * This method writes out the colLabels and rowLabels JSON files. A
	 * boolean is passed in to differentiate between the two during 
	 * processing.  The reOrgMatrix 2-D string array stored on the 
	 * ImportData object is iterated to retrieve values and write them
	 * out to the appropriate JSON file.
	 ******************************************************************/
	private static void writeLabelsFiles(String fileName, ImportData iData, boolean isRowFile) {	
		DataOutputStream writeRow = null;
		OutputStreamWriter w = null;
		try {
			writeRow = new DataOutputStream(new FileOutputStream(fileName));
			w = new OutputStreamWriter(writeRow, UTF8);
			// Build String constants
			w.write(BRACE_OPEN+LINE_FEED+TAB+QUOTE+"Labels"+QUOTE+SPACE+COLON+SPACE);
			w.write(LINE_FEED+TAB+BRACKET_OPEN+LINE_FEED);
			// Loop thru import layers and write out structure data for each.
			if (isRowFile) {
		        for (int row = 1; row < iData.importRows + 1; row++) {
		        	w.write(TAB+TAB+QUOTE+iData.reorgMatrix[row][0]+QUOTE);
					if (row < (iData.importRows)) {
						w.write(COMMA);
						w.write(LINE_FEED);
					}
		        }
			} else {
		        for (int col = 1; col < iData.importCols + 1; col++) {
		        	w.write(TAB+TAB+QUOTE+iData.reorgMatrix[0][col]+QUOTE);
					if (col < (iData.importCols)) {
						w.write(COMMA);
						w.write(LINE_FEED);
					}
		        }
			}
			w.write(LINE_FEED+TAB+BRACKET_CLOSE+LINE_FEED+BRACE_CLOSE);
			w.close();
			writeRow.close();
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    	try {
	    		w.close();
	    		writeRow.close();
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}
	
	/*******************************************************************
	 * METHOD: writeClusteredDebugFile
	 *
	 * This method is for debugging.  It writes out the clustered
	 * data matrix to a file called clustered.txt in the matrix data dir.
	 ******************************************************************/
	private static void writeClusteredDebugFile(ImportData iData) {	
		DataOutputStream writeRow = null;
		OutputStreamWriter w = null;
		try {
			writeRow = new DataOutputStream(new FileOutputStream(iData.outputDir + "clustered.txt"));
			w = new OutputStreamWriter(writeRow, UTF8);
	        for (int row = 1; row < iData.importRows + 1; row++) {
		        for (int col = 1; col < iData.importCols + 1; col++) {
		        	w.write(iData.reorgMatrix[row][col]);
					if (col < (iData.importCols)) {
						w.write(TAB);
					} else {
						w.write(LINE_FEED);
					}
		        }
	        }
			w.close();
			writeRow.close();
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    	try {
	    		w.close();
	    		writeRow.close();
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}
	
	/*******************************************************************
	 * METHOD: writeDendrogramFile
	 *
	 * This method writes out the dendrogram JSON  file. A FileWriter is 
	 * created for the dendro file and the populateDendrogramFile method 
	 * is called twice (once for the row and once for the column) to fill 
	 * in the dendro file.
	 ******************************************************************/
	private static void writeDendrogramFile(ImportData iData, int interval) {
		try {
			DataOutputStream writer = new DataOutputStream(new FileOutputStream(iData.outputDir+DENDROGRAM_FILE));
			OutputStreamWriter fw = new OutputStreamWriter(writer, UTF8);
	        fw.write(BRACE_OPEN+LINE_FEED);
	        populateDendrogramFile(iData.rowOrder, iData.rowDendroFile, ROW, fw);
	        fw.write(BRACKET_CLOSE+COMMA+LINE_FEED);
	        populateDendrogramFile(iData.colOrder, iData.colDendroFile, COL, fw);
            fw.write(BRACKET_CLOSE+LINE_FEED+BRACE_CLOSE);
	        fw.close();
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    	try {
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}
		
	/*******************************************************************
	 * METHOD: populateDendrogramFile
	 *
	 * This method writes out the dendrogram JSON  file. A string is passed 
	 * in to differentiate row/col during processing. The method uses 
	 * Row/Column HCORDER file to re-order the data located in the Row/Column 
	 * HCDATA file and writes the  result out as a JSON file. 
	 ******************************************************************/
	private static void populateDendrogramFile(int[] order, String dendroFile, String dendroType, OutputStreamWriter fw) {
        try {

            // Reading the data file and writing the output file
            BufferedReader br = new BufferedReader(new FileReader(dendroFile));
            String line = br.readLine(); // skip the first line since it's just labels
            line = br.readLine();
            boolean firstTimeThrough = true;
             fw.write(QUOTE+dendroType+QUOTE+SPACE+COLON+LINE_FEED+TAB+BRACKET_OPEN);
            while (line != null) {
                String[] tokes = line.split(TAB);
                int a = Integer.parseInt(tokes[0]);
                int b = Integer.parseInt(tokes[1]);
                if (a<0){ // Check if first column is referring to a sample
                    a = 0-order[0-a];
                }
                if (b<0){ // Check if second column is referring to a sample
                    b = 0-order[0-b];
                }
                if (firstTimeThrough){
                    firstTimeThrough = false;
                } else {
                    fw.write(COMMA+LINE_FEED+TAB);
                }
                fw.write(QUOTE+ a +COMMA+ b +COMMA+ tokes[2] + QUOTE);
                line = br.readLine();
            }
            br.close();
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    	try {
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}
	
	/*******************************************************************
	 * METHOD: writeClassificationsFile
	 *
	 * This method writes out the classifications JSON file. An output stream
	 * is created for writing out the classifications.JSON file. The list of 
	 * classification files, stored on the ImportData object, is iterated for 
	 * each file.  The reOrderClassificationFile method is called to 
	 * order each classification file in clustered order. Then the 
	 * populateClassifications is called to write rows to the output file.
	 ******************************************************************/
	private static void writeClassificationsFile(ImportData iData, int interval) {
		try {
			DataOutputStream writer = new DataOutputStream(new FileOutputStream(iData.outputDir+CLASSIFICATIONS_FILE));
			OutputStreamWriter fw = new OutputStreamWriter(writer, UTF8);
			if (iData.colClassFiles.size()+iData.rowClassFiles.size() == 0) {
				fw.write(BRACE_OPEN+BRACE_CLOSE);
			} else {
		        fw.write(BRACE_OPEN+LINE_FEED+TAB);
		        for (int i=0;i<iData.colClassFiles.size();i++) {
			        ColorMap currColFile = iData.colClassFiles.get(i);
		        	String reOrgClass[][] = reOrderClassificationFile(currColFile, iData.colOrder);
			        populateClassificationsFile(currColFile, reOrgClass, fw, interval);
		        	if ((i != iData.colClassFiles.size() - 1) || (iData.rowClassFiles.size() > 0)) {
		        		fw.write(TAB+BRACE_CLOSE+COMMA+LINE_FEED+TAB);
		        	}
		        }
		        for (int i=0;i<iData.rowClassFiles.size();i++) {
		        	ColorMap currRowFile = iData.rowClassFiles.get(i);
		        	String reOrgClass[][] = reOrderClassificationFile(currRowFile, iData.rowOrder);
		        	populateClassificationsFile(currRowFile, reOrgClass, fw, interval);
		        } 
	            fw.write(TAB+BRACE_CLOSE+LINE_FEED+BRACE_CLOSE);
			}
	        fw.close();
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    	try {
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}

	/*******************************************************************
	 * METHOD: reOrderClassificationFile
	 *
	 * This method re-orders a classification file in clustered order.
	 ******************************************************************/
	private static String[][] reOrderClassificationFile(ColorMap classFile, int[] order) {
		String reorg[][] = new String[order.length][2];
		try {
            // Reading the data file and writing the output file
            BufferedReader br = new BufferedReader(new FileReader(classFile.file));
            String line = br.readLine(); // skip header row
	        String origClass[][] = new String[order.length][2];
	        int pos = 1;
	        while(line !=null) {
	              String toks[] = line.split("\t");
	              for (int i = 0; i < toks.length; i++) {
	            	  origClass[pos][i] = toks[i];
	              }      
	              pos++;
	              line = br.readLine();
	        }
            br.close();
            
	        // Create a new 2D string array and populate it with data from the 
	        // initial 2D array placing it in the clustered order.
	        for (int row = 0; row < order.length; row++) {
	              reorg[order[row]] = origClass[row];
	        }
	        
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    	try {
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
		return reorg;
	}
	
	/*******************************************************************
	 * METHOD: populateClassificationsFile
	 *
	 * This method writes rows into the classifications.JSON file for 
	 * a given input classification file.
	 * 
	 * NOTE: Class File type and colorscheme are currently derived from
	 * the file name and a temporary header row on the classification file
	 * these will eventually come from a CHM.JSON file created by the 
	 * builder.
	 ******************************************************************/
	private static void populateClassificationsFile(ColorMap currFile, String classData[][], OutputStreamWriter fw, int interval) {
        try {
	        fw.write(QUOTE+currFile.name+QUOTE+COLON+LINE_FEED+TAB+BRACE_OPEN+LINE_FEED);
	        fw.write(TAB+TAB+QUOTE+"position"+QUOTE+COLON+QUOTE+currFile.position+QUOTE+COMMA+LINE_FEED);
	        fw.write(TAB+TAB+QUOTE+"height"+QUOTE+COLON+"15"+COMMA+LINE_FEED);
	        fw.write(TAB+TAB+QUOTE+"colorScheme"+QUOTE+COLON+QUOTE+currFile.id+QUOTE+COMMA+LINE_FEED);
	        fw.write(TAB+TAB+QUOTE+"show"+QUOTE+COLON+QUOTE+"Y"+QUOTE+COMMA+LINE_FEED);
	        fw.write(TAB+TAB+QUOTE+"values"+QUOTE+COLON+LINE_FEED+TAB+TAB+BRACKET_OPEN+LINE_FEED);
	        // Write out a separate "values" node containing values for the classification file
	        for (int row = 1; row < classData.length; row++) {
	        	writeClassValue(classData[row][1], row, classData.length, fw, 1);
	        }
	        // Write out a separate "svalues" node containing values for the classification file
	        // this dataset will be sampled at the same level as the summary layer.
	        if (interval > 1) {
		        fw.write(COMMA+LINE_FEED+TAB+TAB+QUOTE+"svalues"+QUOTE+COLON+LINE_FEED+TAB+TAB+BRACKET_OPEN+LINE_FEED);
		        for (int row = 1; row < classData.length; row++) {
		        	int adjustedPos = row - 1;
		    		float remainder = ((float)adjustedPos/interval)%1;
		    		if (remainder == 0) {
			        	writeClassValue(classData[row][1], row, classData.length, fw, interval);
		    		}
		        }
	        } 
        	fw.write(LINE_FEED);
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    	try {
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}
	private static void writeClassValue(String val, int row, int len, OutputStreamWriter fw, int interval) {
        try {
        	if (isNumeric(val)) {
        		fw.write(TAB+TAB+val);
        	} else {
        		fw.write(TAB+TAB+QUOTE+val+QUOTE);
        	}
        	if (row+interval < len) {
        		fw.write(COMMA+LINE_FEED);
        	} else {
        		fw.write(BRACKET_CLOSE);
        	}
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    	try {
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}
	
	/*******************************************************************
	 * METHOD: writeClassificationsFile
	 *
	 * This method writes out the classifications JSON file. An output stream
	 * is created for writing out the classifications.JSON file. The list of 
	 * classification files, stored on the ImportData object, is iterated for 
	 * each file.  The reOrderClassificationFile method is called to 
	 * order each classification file in clustered order. Then the 
	 * populateClassifications is called to write rows to the output file.
	 ******************************************************************/
	private static void writeColorMapFile(ImportData iData) {
		try {
			DataOutputStream writer = new DataOutputStream(new FileOutputStream(iData.outputDir+COLORMAPS_FILE));
			OutputStreamWriter fw = new OutputStreamWriter(writer, UTF8);
	        fw.write(BRACE_OPEN+COLORMAPS_LABEL+LINE_FEED+TAB+BRACE_OPEN+LINE_FEED);
	        fw.write(iData.matrixFile.asJSON());
	        if (iData.colClassFiles.size()+iData.rowClassFiles.size() > 0) {
	        	fw.write(TAB+COMMA+LINE_FEED);
	        }
	        for (int i=0;i<iData.colClassFiles.size();i++) {
		        ColorMap currColFile = iData.colClassFiles.get(i);
		        fw.write(currColFile.asJSON());
	        	if ((i != iData.colClassFiles.size() - 1) || (iData.rowClassFiles.size() > 0)) {
	        		fw.write(TAB+COMMA+LINE_FEED);
	        	}
	        } 
	        for (int i=0;i<iData.rowClassFiles.size();i++) {
		        ColorMap currRowFile = iData.rowClassFiles.get(i);
		        fw.write(currRowFile.asJSON());
	        	if (i != iData.rowClassFiles.size() - 1) {
	        		fw.write(TAB+COMMA+LINE_FEED);
	        	}
	        } 
            fw.write(LINE_FEED+TAB+BRACE_CLOSE+LINE_FEED+BRACE_CLOSE);
	        fw.close();
	    } catch (Exception ex) {
	    	System.out.println("Exception: "+ ex.toString());
	    } finally {
	    	try {
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}


}
